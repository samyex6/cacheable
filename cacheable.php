<?php

/**
 * Main usage explain
 * - N/A
 * Data explain
 * - $extendpre: Use to define the name of child class
 * - $rfscache: Only sets with true when updating cache
 * - $param: Extra parameters for extended methods
 */
class Cacheable {

    public static $extendpre  = 'CC';
    public static $rfscache   = FALSE;
    public static $param      = [];
    public static $path_css   = '';
    public static $path_cache = '';
    public static $id         = 0;

    /**
     * Generate a parsable PHP file with an array.
     * @param $data
     * @param $filepath
     * @return bool
     */
    public static function Write($data, $filepath) {

        $writeFrag = '';

        foreach($data as $key => $value)
            $writeFrag .= '$' . $key . ' = ' . var_export($value, TRUE) . ';' . PHP_EOL;

        $writeIn = '<?php' . PHP_EOL . PHP_EOL .
            '/**' . PHP_EOL .
            ' * This is a cache file generated by the class Cache.' . PHP_EOL .
            ' * Generated time: ' . date('Y-m-d H:i:s', $_SERVER['REQUEST_TIME']) . PHP_EOL .
            ' */' . PHP_EOL . PHP_EOL . $writeFrag .
            '?>';

        return ($fp = fopen($filepath, 'w')) && flock($fp, LOCK_EX) && fwrite($fp, $writeIn) && flock($fp, LOCK_UN) && fclose($fp);

    }

    /**
     * Obtain the parsed CSS file path name
     * @param        $filename
     * @param string $varfilename
     * @return bool|string
     */
    public static function Css($filename, $varfilename = '') {

        $file    = '';
        $frmfile = '';
        $objfile = self::$path_cache . '/css_' . self::$id . '_' . implode('-', $filename) . '.css';
        $varfile = self::$path_css . '/' . $varfilename . '.php';
        $frmtime = filemtime($frmfile);

        // Time cross check, if the file's creation time is still cool then there's no need to re-parse.
        //if(file_exists($objfile) && $_SERVER['REQUEST_TIME'] - $frmtime < 900) return $objfile;

        // Save the contents in css file into a variable
        foreach($filename as $val) {
            $frmfile = self::$path_css . '/' . $val . '.css';
            file_exists($frmfile) && $file .= file_get_contents($frmfile);
        }

        // Replace %%variable%% in templates to actual values
        $pattern = $replacement = [];
        if(!empty($varfilename) && file_exists($varfile)) {
            include_once $varfile;
            if(!empty($cssvar)) {
                foreach($cssvar as $name => $val) {
                    $pattern[$name]     = '/_' . $name . '_/';
                    $replacement[$name] = $val;
                }
                $file = preg_replace($pattern, $replacement, $file); // variables
            }
        }

        // Replace other stuff such as comments, special signs (:;), white spaces and etc.
        $file = preg_replace('/\/\*.+?\*\//', '', $file);
        $file = preg_replace('/\s*([\;\:,])\s*/', '\\1', $file);
        $file = preg_replace('/[\s]{0,}([\{\}])[\s]+/', '\\1', $file);
        $file = preg_replace('/[\n\r]/', '', $file);
        $file = preg_replace('/;\s*\}/', '}', $file);

        // This one is to convert hex color & transparency into rgba values
        $file = preg_replace_callback('/_([a-zA-Z\-]+?)\-\-([0-9]+?)_/', function ($matches) use ($replacement) {
            if(empty($replacement[$matches[1]])) return $matches[0];
            $parts = array_map(function ($str) {
                return base_convert($str, 16, 10);
            }, str_split(trim($replacement[$matches[1]], '#'), 2));
            return 'rgba(' . $parts[0] . ', ' . $parts[1] . ', ' . $parts[2] . ', ' . $matches[2] . ')';
        }, $file);

        $fp = fopen($objfile, 'w+');
        if(in_array(FALSE, [flock($fp, LOCK_EX), fwrite($fp, $file), flock($fp, LOCK_UN)], TRUE)) return FALSE;

        return $objfile;
    }

    /**
     * @param $actionArr
     * @return bool
     */
    public static function Refresh($actionArr = []) {

        if(empty($actionArr)) return FALSE;

        self::$rfscache = TRUE;
        foreach($actionArr as $action)
            if(self::Load($action) === FALSE) return FALSE;

        return TRUE;

    }

    public static function Load($action, $extra = []) {
        self::$param = $extra;
        return call_user_func([self::$extendpre, '__' . $action]);
    }

}
